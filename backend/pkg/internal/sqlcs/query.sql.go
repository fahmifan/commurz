// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package sqlcs

import (
	"context"
	"strings"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const bumpProductVersion = `-- name: BumpProductVersion :one
UPDATE products SET version = version + 1 
WHERE id = $1 AND version = $2
RETURNING id, name, price, version
`

type BumpProductVersionParams struct {
	ID             string
	CurrentVersion int64
}

func (q *Queries) BumpProductVersion(ctx context.Context, arg BumpProductVersionParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, bumpProductVersion, arg.ID, arg.CurrentVersion)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
	)
	return i, err
}

const createCart = `-- name: CreateCart :one
INSERT INTO carts (id, user_id)
VALUES ($1, $2)
RETURNING id, user_id
`

type CreateCartParams struct {
	ID     string
	UserID uuid.UUID
}

func (q *Queries) CreateCart(ctx context.Context, arg CreateCartParams) (Cart, error) {
	row := q.db.QueryRowContext(ctx, createCart, arg.ID, arg.UserID)
	var i Cart
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const createProductStock = `-- name: CreateProductStock :one
INSERT INTO product_stocks (id, product_id, stock_in, stock_out)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, stock_in, stock_out, created_at
`

type CreateProductStockParams struct {
	ID        string
	ProductID string
	StockIn   int64
	StockOut  int64
}

func (q *Queries) CreateProductStock(ctx context.Context, arg CreateProductStockParams) (ProductStock, error) {
	row := q.db.QueryRowContext(ctx, createProductStock,
		arg.ID,
		arg.ProductID,
		arg.StockIn,
		arg.StockOut,
	)
	var i ProductStock
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.StockIn,
		&i.StockOut,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email)
VALUES ($1, $2)
RETURNING id, email, name, password_hash, verify_token, status, last_login_at, archived, created_at, updated_at, role
`

type CreateUserParams struct {
	ID    uuid.UUID
	Email string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.VerifyToken,
		&i.Status,
		&i.LastLoginAt,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
	)
	return i, err
}

const deleteCart = `-- name: DeleteCart :exec
DELETE FROM carts WHERE id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCart, id)
	return err
}

const findAllCartItemsByCartIDs = `-- name: FindAllCartItemsByCartIDs :many
SELECT id, cart_id, product_id, quantity, price FROM cart_items WHERE cart_id IN ($1)
`

func (q *Queries) FindAllCartItemsByCartIDs(ctx context.Context, cartIds []string) ([]CartItem, error) {
	query := findAllCartItemsByCartIDs
	var queryParams []interface{}
	if len(cartIds) > 0 {
		for _, v := range cartIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:cart_ids*/?", strings.Repeat(",?", len(cartIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:cart_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CartItem
	for rows.Next() {
		var i CartItem
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllProductStocksByIDs = `-- name: FindAllProductStocksByIDs :many
SELECT id, product_id, stock_in, stock_out, created_at FROM product_stocks WHERE product_id = ANY($1::TEXT[])
`

func (q *Queries) FindAllProductStocksByIDs(ctx context.Context, productIds []string) ([]ProductStock, error) {
	rows, err := q.db.QueryContext(ctx, findAllProductStocksByIDs, pq.Array(productIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductStock
	for rows.Next() {
		var i ProductStock
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.StockIn,
			&i.StockOut,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllProductsByIDs = `-- name: FindAllProductsByIDs :many
SELECT id, name, price, version FROM products WHERE id IN ($1)
`

func (q *Queries) FindAllProductsByIDs(ctx context.Context, productIds []string) ([]Product, error) {
	query := findAllProductsByIDs
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllUsers = `-- name: FindAllUsers :many
SELECT id, email, name, password_hash, verify_token, status, last_login_at, archived, created_at, updated_at, role FROM users
`

func (q *Queries) FindAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, findAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.PasswordHash,
			&i.VerifyToken,
			&i.Status,
			&i.LastLoginAt,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCartByUserID = `-- name: FindCartByUserID :one
SELECT id, user_id FROM carts WHERE user_id = $1
`

func (q *Queries) FindCartByUserID(ctx context.Context, userID uuid.UUID) (Cart, error) {
	row := q.db.QueryRowContext(ctx, findCartByUserID, userID)
	var i Cart
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const findProductByID = `-- name: FindProductByID :one
SELECT id, name, price, version FROM products WHERE id = $1
`

func (q *Queries) FindProductByID(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRowContext(ctx, findProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, name, password_hash, verify_token, status, last_login_at, archived, created_at, updated_at, role FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.VerifyToken,
		&i.Status,
		&i.LastLoginAt,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, email, name, password_hash, verify_token, status, last_login_at, archived, created_at, updated_at, role FROM users WHERE id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.VerifyToken,
		&i.Status,
		&i.LastLoginAt,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
	)
	return i, err
}

const saveCartItem = `-- name: SaveCartItem :one
INSERT INTO cart_items (id, cart_id, product_id, quantity, price) 
VALUES ($1, $2, $3, $4, $5)
RETURNING id, cart_id, product_id, quantity, price
`

type SaveCartItemParams struct {
	ID        string
	CartID    string
	ProductID string
	Quantity  int64
	Price     int64
}

func (q *Queries) SaveCartItem(ctx context.Context, arg SaveCartItemParams) (CartItem, error) {
	row := q.db.QueryRowContext(ctx, saveCartItem,
		arg.ID,
		arg.CartID,
		arg.ProductID,
		arg.Quantity,
		arg.Price,
	)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Quantity,
		&i.Price,
	)
	return i, err
}

const saveProduct = `-- name: SaveProduct :one
INSERT INTO products (id, name, price)
VALUES ($1, $2, $3)
RETURNING id, name, price, version
`

type SaveProductParams struct {
	ID    string
	Name  string
	Price int64
}

func (q *Queries) SaveProduct(ctx context.Context, arg SaveProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, saveProduct, arg.ID, arg.Name, arg.Price)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET 
    name = $1, 
    price = $2 
WHERE 
    id = $3 
RETURNING id, name, price, version
`

type UpdateProductParams struct {
	Name  string
	Price int64
	ID    string
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct, arg.Name, arg.Price, arg.ID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
	)
	return i, err
}
