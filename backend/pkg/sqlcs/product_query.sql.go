// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: product_query.sql

package sqlcs

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const bumpProductVersion = `-- name: BumpProductVersion :one
UPDATE products SET version = version + 1 
WHERE id = $1 AND version = $2
RETURNING id, name, price, version, latest_stock
`

type BumpProductVersionParams struct {
	ID             string
	CurrentVersion int64
}

func (q *Queries) BumpProductVersion(ctx context.Context, arg BumpProductVersionParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, bumpProductVersion, arg.ID, arg.CurrentVersion)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
		&i.LatestStock,
	)
	return i, err
}

const countAllProductsForBackoffice = `-- name: CountAllProductsForBackoffice :one
SELECT COUNT(*) FROM products
WHERE 
    CASE WHEN $1::bool THEN ("name" LIKE '%' || $2 || '%') ELSE TRUE END
`

type CountAllProductsForBackofficeParams struct {
	SetName bool
	Name    sql.NullString
}

func (q *Queries) CountAllProductsForBackoffice(ctx context.Context, arg CountAllProductsForBackofficeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllProductsForBackoffice, arg.SetName, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllProductsListing = `-- name: CountAllProductsListing :one
SELECT COUNT(*) FROM products
WHERE 
    CASE WHEN $1::bool THEN ("name" LIKE '%' || $2 || '%') ELSE TRUE END
`

type CountAllProductsListingParams struct {
	SetName bool
	Name    sql.NullString
}

func (q *Queries) CountAllProductsListing(ctx context.Context, arg CountAllProductsListingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllProductsListing, arg.SetName, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductStock = `-- name: CreateProductStock :one
INSERT INTO product_stocks (id, product_id, stock_in, stock_out)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, stock_in, stock_out, created_at
`

type CreateProductStockParams struct {
	ID        string
	ProductID string
	StockIn   int64
	StockOut  int64
}

func (q *Queries) CreateProductStock(ctx context.Context, arg CreateProductStockParams) (ProductStock, error) {
	row := q.db.QueryRowContext(ctx, createProductStock,
		arg.ID,
		arg.ProductID,
		arg.StockIn,
		arg.StockOut,
	)
	var i ProductStock
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.StockIn,
		&i.StockOut,
		&i.CreatedAt,
	)
	return i, err
}

const createProductStockLock = `-- name: CreateProductStockLock :one
INSERT INTO product_stock_lock (id, product_id) VALUES ($1, $1) RETURNING id, product_id
`

func (q *Queries) CreateProductStockLock(ctx context.Context, productID string) (ProductStockLock, error) {
	row := q.db.QueryRowContext(ctx, createProductStockLock, productID)
	var i ProductStockLock
	err := row.Scan(&i.ID, &i.ProductID)
	return i, err
}

const findAllProductListing = `-- name: FindAllProductListing :many
SELECT id, name, price, version, latest_stock FROM products
WHERE 
    CASE WHEN $1::bool THEN ("name" LIKE '%' || $2 || '%') ELSE TRUE END
ORDER BY id DESC
LIMIT $4
OFFSET $3
`

type FindAllProductListingParams struct {
	SetName    bool
	Name       sql.NullString
	PageOffset int32
	PageLimit  int32
}

func (q *Queries) FindAllProductListing(ctx context.Context, arg FindAllProductListingParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, findAllProductListing,
		arg.SetName,
		arg.Name,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Version,
			&i.LatestStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllProductStocksByIDs = `-- name: FindAllProductStocksByIDs :many
SELECT id, product_id, stock_in, stock_out, created_at FROM product_stocks WHERE product_id = ANY($1::TEXT[])
`

func (q *Queries) FindAllProductStocksByIDs(ctx context.Context, productIds []string) ([]ProductStock, error) {
	rows, err := q.db.QueryContext(ctx, findAllProductStocksByIDs, pq.Array(productIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductStock
	for rows.Next() {
		var i ProductStock
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.StockIn,
			&i.StockOut,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllProductsByIDs = `-- name: FindAllProductsByIDs :many
SELECT id, name, price, version, latest_stock FROM products WHERE id = ANY($1::TEXT[])
`

func (q *Queries) FindAllProductsByIDs(ctx context.Context, productIds []string) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, findAllProductsByIDs, pq.Array(productIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Version,
			&i.LatestStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllProductsByIDslockProductStock = `-- name: FindAllProductsByIDslockProductStock :one
SELECT id, name, price, version, latest_stock FROM products WHERE id = ANY($1::TEXT[]) FOR UPDATE
`

func (q *Queries) FindAllProductsByIDslockProductStock(ctx context.Context, ids []string) (Product, error) {
	row := q.db.QueryRowContext(ctx, findAllProductsByIDslockProductStock, pq.Array(ids))
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
		&i.LatestStock,
	)
	return i, err
}

const findAllProductsForBackoffice = `-- name: FindAllProductsForBackoffice :many
SELECT id, name, price, version, latest_stock FROM products
WHERE 
    CASE WHEN $1::bool THEN ("name" LIKE '%' || $2 || '%') ELSE TRUE END
ORDER BY id DESC
LIMIT $4
OFFSET $3
`

type FindAllProductsForBackofficeParams struct {
	SetName    bool
	Name       sql.NullString
	PageOffset int32
	PageLimit  int32
}

func (q *Queries) FindAllProductsForBackoffice(ctx context.Context, arg FindAllProductsForBackofficeParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, findAllProductsForBackoffice,
		arg.SetName,
		arg.Name,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Version,
			&i.LatestStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProductByID = `-- name: FindProductByID :one
SELECT id, name, price, version, latest_stock FROM products WHERE id = $1
`

func (q *Queries) FindProductByID(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRowContext(ctx, findProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
		&i.LatestStock,
	)
	return i, err
}

const lockProductStock = `-- name: LockProductStock :one
SELECT id, product_id FROM product_stock_lock WHERE product_id = ANY($1::TEXT[]) FOR UPDATE
`

func (q *Queries) LockProductStock(ctx context.Context, productID []string) (ProductStockLock, error) {
	row := q.db.QueryRowContext(ctx, lockProductStock, pq.Array(productID))
	var i ProductStockLock
	err := row.Scan(&i.ID, &i.ProductID)
	return i, err
}

const saveProduct = `-- name: SaveProduct :one
INSERT INTO products (id, name, price)
VALUES ($1, $2, $3)
RETURNING id, name, price, version, latest_stock
`

type SaveProductParams struct {
	ID    string
	Name  string
	Price int64
}

func (q *Queries) SaveProduct(ctx context.Context, arg SaveProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, saveProduct, arg.ID, arg.Name, arg.Price)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
		&i.LatestStock,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET 
    name = $1, 
    price = $2,
    latest_stock = $3,
    version = version + 1
WHERE 
    id = $4 
    AND version = $5
RETURNING id, name, price, version, latest_stock
`

type UpdateProductParams struct {
	Name           string
	Price          int64
	LatestStock    int64
	ID             string
	CurrentVersion int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.Name,
		arg.Price,
		arg.LatestStock,
		arg.ID,
		arg.CurrentVersion,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Version,
		&i.LatestStock,
	)
	return i, err
}
